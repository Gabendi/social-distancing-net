<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>social-distancing-net.yolo3_one_file_to_detect_them_all API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>social-distancing-net.yolo3_one_file_to_detect_them_all</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import argparse
import os
import numpy as np
from tensorflow.keras.layers import Conv2D, Input, BatchNormalization, LeakyReLU, ZeroPadding2D, UpSampling2D, add, concatenate
from tensorflow.keras.models import Model
import struct
import cv2

argparser = argparse.ArgumentParser(
    description=&#39;test yolov3 network with coco weights&#39;)

argparser.add_argument(
    &#39;-w&#39;,
    &#39;--weights&#39;,
    help=&#39;path to weights file&#39;)

argparser.add_argument(
    &#39;-i&#39;,
    &#39;--image&#39;,
    help=&#39;path to image file&#39;)

class WeightReader:
    def __init__(self, weight_file):
        with open(weight_file, &#39;rb&#39;) as w_f:
            major,    = struct.unpack(&#39;i&#39;, w_f.read(4))
            minor,    = struct.unpack(&#39;i&#39;, w_f.read(4))
            revision, = struct.unpack(&#39;i&#39;, w_f.read(4))

            if (major*10 + minor) &gt;= 2 and major &lt; 1000 and minor &lt; 1000:
                w_f.read(8)
            else:
                w_f.read(4)

            transpose = (major &gt; 1000) or (minor &gt; 1000)
            
            binary = w_f.read()

        self.offset = 0
        self.all_weights = np.frombuffer(binary, dtype=&#39;float32&#39;)
        
    def read_bytes(self, size):
        self.offset = self.offset + size
        return self.all_weights[self.offset-size:self.offset]

    def load_weights(self, model):
        for i in range(106):
            try:
                conv_layer = model.get_layer(&#39;conv_&#39; + str(i))
                print(&#34;loading weights of convolution #&#34; + str(i))

                if i not in [81, 93, 105]:
                    norm_layer = model.get_layer(&#39;bnorm_&#39; + str(i))

                    size = np.prod(norm_layer.get_weights()[0].shape)

                    beta  = self.read_bytes(size) # bias
                    gamma = self.read_bytes(size) # scale
                    mean  = self.read_bytes(size) # mean
                    var   = self.read_bytes(size) # variance            

                    weights = norm_layer.set_weights([gamma, beta, mean, var])  

                if len(conv_layer.get_weights()) &gt; 1:
                    bias   = self.read_bytes(np.prod(conv_layer.get_weights()[1].shape))
                    kernel = self.read_bytes(np.prod(conv_layer.get_weights()[0].shape))
                    
                    kernel = kernel.reshape(list(reversed(conv_layer.get_weights()[0].shape)))
                    kernel = kernel.transpose([2,3,1,0])
                    conv_layer.set_weights([kernel, bias])
                else:
                    kernel = self.read_bytes(np.prod(conv_layer.get_weights()[0].shape))
                    kernel = kernel.reshape(list(reversed(conv_layer.get_weights()[0].shape)))
                    kernel = kernel.transpose([2,3,1,0])
                    conv_layer.set_weights([kernel])
            except ValueError:
                print(&#34;no convolution #&#34; + str(i))     
    
    def reset(self):
        self.offset = 0

class BoundBox:
    def __init__(self, xmin, ymin, xmax, ymax, objness = None, classes = None):
        self.xmin = xmin
        self.ymin = ymin
        self.xmax = xmax
        self.ymax = ymax
        
        self.objness = objness
        self.classes = classes

        self.label = -1
        self.score = -1

    def get_label(self):
        if self.label == -1:
            self.label = np.argmax(self.classes)
        
        return self.label
    
    def get_score(self):
        if self.score == -1:
            self.score = self.classes[self.get_label()]
            
        return self.score

def _conv_block(inp, convs, skip=True):
    x = inp
    count = 0
    
    for conv in convs:
        if count == (len(convs) - 2) and skip:
            skip_connection = x
        count += 1
        
        if conv[&#39;stride&#39;] &gt; 1: x = ZeroPadding2D(((1,0),(1,0)))(x) # peculiar padding as darknet prefer left and top
        x = Conv2D(conv[&#39;filter&#39;], 
                   conv[&#39;kernel&#39;], 
                   strides=conv[&#39;stride&#39;], 
                   padding=&#39;valid&#39; if conv[&#39;stride&#39;] &gt; 1 else &#39;same&#39;, # peculiar padding as darknet prefer left and top
                   name=&#39;conv_&#39; + str(conv[&#39;layer_idx&#39;]), 
                   use_bias=False if conv[&#39;bnorm&#39;] else True)(x)
        if conv[&#39;bnorm&#39;]: x = BatchNormalization(epsilon=0.001, name=&#39;bnorm_&#39; + str(conv[&#39;layer_idx&#39;]))(x)
        if conv[&#39;leaky&#39;]: x = LeakyReLU(alpha=0.1, name=&#39;leaky_&#39; + str(conv[&#39;layer_idx&#39;]))(x)

    return add([skip_connection, x]) if skip else x

def _interval_overlap(interval_a, interval_b):
    x1, x2 = interval_a
    x3, x4 = interval_b

    if x3 &lt; x1:
        if x4 &lt; x1:
            return 0
        else:
            return min(x2,x4) - x1
    else:
        if x2 &lt; x3:
             return 0
        else:
            return min(x2,x4) - x3          

def _sigmoid(x):
    return 1. / (1. + np.exp(-x))

def bbox_iou(box1, box2):
    intersect_w = _interval_overlap([box1.xmin, box1.xmax], [box2.xmin, box2.xmax])
    intersect_h = _interval_overlap([box1.ymin, box1.ymax], [box2.ymin, box2.ymax])
    
    intersect = intersect_w * intersect_h

    w1, h1 = box1.xmax-box1.xmin, box1.ymax-box1.ymin
    w2, h2 = box2.xmax-box2.xmin, box2.ymax-box2.ymin
    
    union = w1*h1 + w2*h2 - intersect
    
    return float(intersect) / union

def make_yolov3_model():
    input_image = Input(shape=(None, None, 3))

    # Layer  0 =&gt; 4
    x = _conv_block(input_image, [{&#39;filter&#39;: 32, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 0},
                                  {&#39;filter&#39;: 64, &#39;kernel&#39;: 3, &#39;stride&#39;: 2, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 1},
                                  {&#39;filter&#39;: 32, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 2},
                                  {&#39;filter&#39;: 64, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 3}])

    # Layer  5 =&gt; 8
    x = _conv_block(x, [{&#39;filter&#39;: 128, &#39;kernel&#39;: 3, &#39;stride&#39;: 2, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 5},
                        {&#39;filter&#39;:  64, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 6},
                        {&#39;filter&#39;: 128, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 7}])

    # Layer  9 =&gt; 11
    x = _conv_block(x, [{&#39;filter&#39;:  64, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 9},
                        {&#39;filter&#39;: 128, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 10}])

    # Layer 12 =&gt; 15
    x = _conv_block(x, [{&#39;filter&#39;: 256, &#39;kernel&#39;: 3, &#39;stride&#39;: 2, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 12},
                        {&#39;filter&#39;: 128, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 13},
                        {&#39;filter&#39;: 256, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 14}])

    # Layer 16 =&gt; 36
    for i in range(7):
        x = _conv_block(x, [{&#39;filter&#39;: 128, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 16+i*3},
                            {&#39;filter&#39;: 256, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 17+i*3}])
        
    skip_36 = x
        
    # Layer 37 =&gt; 40
    x = _conv_block(x, [{&#39;filter&#39;: 512, &#39;kernel&#39;: 3, &#39;stride&#39;: 2, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 37},
                        {&#39;filter&#39;: 256, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 38},
                        {&#39;filter&#39;: 512, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 39}])

    # Layer 41 =&gt; 61
    for i in range(7):
        x = _conv_block(x, [{&#39;filter&#39;: 256, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 41+i*3},
                            {&#39;filter&#39;: 512, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 42+i*3}])
        
    skip_61 = x
        
    # Layer 62 =&gt; 65
    x = _conv_block(x, [{&#39;filter&#39;: 1024, &#39;kernel&#39;: 3, &#39;stride&#39;: 2, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 62},
                        {&#39;filter&#39;:  512, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 63},
                        {&#39;filter&#39;: 1024, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 64}])

    # Layer 66 =&gt; 74
    for i in range(3):
        x = _conv_block(x, [{&#39;filter&#39;:  512, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 66+i*3},
                            {&#39;filter&#39;: 1024, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 67+i*3}])
        
    # Layer 75 =&gt; 79
    x = _conv_block(x, [{&#39;filter&#39;:  512, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 75},
                        {&#39;filter&#39;: 1024, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 76},
                        {&#39;filter&#39;:  512, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 77},
                        {&#39;filter&#39;: 1024, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 78},
                        {&#39;filter&#39;:  512, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 79}], skip=False)

    # Layer 80 =&gt; 82
    yolo_82 = _conv_block(x, [{&#39;filter&#39;: 1024, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True,  &#39;leaky&#39;: True,  &#39;layer_idx&#39;: 80},
                              {&#39;filter&#39;:  255, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: False, &#39;leaky&#39;: False, &#39;layer_idx&#39;: 81}], skip=False)

    # Layer 83 =&gt; 86
    x = _conv_block(x, [{&#39;filter&#39;: 256, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 84}], skip=False)
    x = UpSampling2D(2)(x)
    x = concatenate([x, skip_61])

    # Layer 87 =&gt; 91
    x = _conv_block(x, [{&#39;filter&#39;: 256, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 87},
                        {&#39;filter&#39;: 512, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 88},
                        {&#39;filter&#39;: 256, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 89},
                        {&#39;filter&#39;: 512, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 90},
                        {&#39;filter&#39;: 256, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 91}], skip=False)

    # Layer 92 =&gt; 94
    yolo_94 = _conv_block(x, [{&#39;filter&#39;: 512, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True,  &#39;leaky&#39;: True,  &#39;layer_idx&#39;: 92},
                              {&#39;filter&#39;: 255, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: False, &#39;leaky&#39;: False, &#39;layer_idx&#39;: 93}], skip=False)

    # Layer 95 =&gt; 98
    x = _conv_block(x, [{&#39;filter&#39;: 128, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True,   &#39;layer_idx&#39;: 96}], skip=False)
    x = UpSampling2D(2)(x)
    x = concatenate([x, skip_36])

    # Layer 99 =&gt; 106
    yolo_106 = _conv_block(x, [{&#39;filter&#39;: 128, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True,  &#39;leaky&#39;: True,  &#39;layer_idx&#39;: 99},
                               {&#39;filter&#39;: 256, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True,  &#39;leaky&#39;: True,  &#39;layer_idx&#39;: 100},
                               {&#39;filter&#39;: 128, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True,  &#39;leaky&#39;: True,  &#39;layer_idx&#39;: 101},
                               {&#39;filter&#39;: 256, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True,  &#39;leaky&#39;: True,  &#39;layer_idx&#39;: 102},
                               {&#39;filter&#39;: 128, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True,  &#39;leaky&#39;: True,  &#39;layer_idx&#39;: 103},
                               {&#39;filter&#39;: 256, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True,  &#39;leaky&#39;: True,  &#39;layer_idx&#39;: 104},
                               {&#39;filter&#39;: 255, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: False, &#39;leaky&#39;: False, &#39;layer_idx&#39;: 105}], skip=False)

    model = Model(input_image, [yolo_82, yolo_94, yolo_106])    
    return model

def preprocess_input(image, net_h, net_w):
    new_h, new_w, _ = image.shape

    # determine the new size of the image
    if (float(net_w)/new_w) &lt; (float(net_h)/new_h):
        new_h = (new_h * net_w)/new_w
        new_w = net_w
    else:
        new_w = (new_w * net_h)/new_h
        new_h = net_h

    # resize the image to the new size
    resized = cv2.resize(image[:,:,::-1]/255., (int(new_w), int(new_h)))

    # embed the image into the standard letter box
    new_image = np.ones((net_h, net_w, 3)) * 0.5
    new_image[int((net_h-new_h)//2):int((net_h+new_h)//2), int((net_w-new_w)//2):int((net_w+new_w)//2), :] = resized
    new_image = np.expand_dims(new_image, 0)

    return new_image

def decode_netout(netout, anchors, obj_thresh, net_h, net_w):
    grid_h, grid_w = netout.shape[:2]
    nb_box = 3
    netout = netout.reshape((grid_h, grid_w, nb_box, -1))
    nb_class = netout.shape[-1] - 5

    boxes = []

    netout[..., :2]  = _sigmoid(netout[..., :2])
    netout[..., 4:]  = _sigmoid(netout[..., 4:])
    netout[..., 5:]  = netout[..., 4][..., np.newaxis] * netout[..., 5:]
    netout[..., 5:] *= netout[..., 5:] &gt; obj_thresh

    for i in range(grid_h*grid_w):
        row = i / grid_w
        col = i % grid_w
        
        for b in range(nb_box):
            # 4th element is objectness score
            objectness = netout[int(row)][int(col)][b][4]
            #objectness = netout[..., :4]
            
            if(objectness.all() &lt;= obj_thresh): continue
            
            # first 4 elements are x, y, w, and h
            x, y, w, h = netout[int(row)][int(col)][b][:4]

            x = (col + x) / grid_w # center position, unit: image width
            y = (row + y) / grid_h # center position, unit: image height
            w = anchors[2 * b + 0] * np.exp(w) / net_w # unit: image width
            h = anchors[2 * b + 1] * np.exp(h) / net_h # unit: image height  
            
            # last elements are class probabilities
            classes = netout[int(row)][col][b][5:]
            
            box = BoundBox(x-w/2, y-h/2, x+w/2, y+h/2, objectness, classes)
            #box = BoundBox(x-w/2, y-h/2, x+w/2, y+h/2, None, classes)

            boxes.append(box)

    return boxes

def correct_yolo_boxes(boxes, image_h, image_w, net_h, net_w):
    if (float(net_w)/image_w) &lt; (float(net_h)/image_h):
        new_w = net_w
        new_h = (image_h*net_w)/image_w
    else:
        new_h = net_w
        new_w = (image_w*net_h)/image_h
        
    for i in range(len(boxes)):
        x_offset, x_scale = (net_w - new_w)/2./net_w, float(new_w)/net_w
        y_offset, y_scale = (net_h - new_h)/2./net_h, float(new_h)/net_h
        
        boxes[i].xmin = int((boxes[i].xmin - x_offset) / x_scale * image_w)
        boxes[i].xmax = int((boxes[i].xmax - x_offset) / x_scale * image_w)
        boxes[i].ymin = int((boxes[i].ymin - y_offset) / y_scale * image_h)
        boxes[i].ymax = int((boxes[i].ymax - y_offset) / y_scale * image_h)
        
def do_nms(boxes, nms_thresh):
    if len(boxes) &gt; 0:
        nb_class = len(boxes[0].classes)
    else:
        return
        
    for c in range(nb_class):
        sorted_indices = np.argsort([-box.classes[c] for box in boxes])

        for i in range(len(sorted_indices)):
            index_i = sorted_indices[i]

            if boxes[index_i].classes[c] == 0: continue

            for j in range(i+1, len(sorted_indices)):
                index_j = sorted_indices[j]

                if bbox_iou(boxes[index_i], boxes[index_j]) &gt;= nms_thresh:
                    boxes[index_j].classes[c] = 0
                    
def draw_boxes(image, boxes, labels, obj_thresh):
    for box in boxes:
        label_str = &#39;&#39;
        label = -1
        
        for i in range(len(labels)):
            if box.classes[i] &gt; obj_thresh:
                label_str += labels[i]
                label = i
                print(labels[i] + &#39;: &#39; + str(box.classes[i]*100) + &#39;%&#39;)
                
        if label &gt;= 0:
            cv2.rectangle(image, (box.xmin,box.ymin), (box.xmax,box.ymax), (0,255,0), 3)
            cv2.putText(image, 
                        label_str + &#39; &#39; + str(box.get_score()), 
                        (box.xmin, box.ymin - 13), 
                        cv2.FONT_HERSHEY_SIMPLEX, 
                        1e-3 * image.shape[0], 
                        (0,255,0), 2)
        
    return image      

def _main_(args):
    weights_path = args.weights
    image_path   = args.image

    # set some parameters
    net_h, net_w = 416, 416
    obj_thresh, nms_thresh = 0.5, 0.45
    anchors = [[116,90,  156,198,  373,326],  [30,61, 62,45,  59,119], [10,13,  16,30,  33,23]]
    labels = [&#34;person&#34;, &#34;bicycle&#34;, &#34;car&#34;, &#34;motorbike&#34;, &#34;aeroplane&#34;, &#34;bus&#34;, &#34;train&#34;, &#34;truck&#34;, \
              &#34;boat&#34;, &#34;traffic light&#34;, &#34;fire hydrant&#34;, &#34;stop sign&#34;, &#34;parking meter&#34;, &#34;bench&#34;, \
              &#34;bird&#34;, &#34;cat&#34;, &#34;dog&#34;, &#34;horse&#34;, &#34;sheep&#34;, &#34;cow&#34;, &#34;elephant&#34;, &#34;bear&#34;, &#34;zebra&#34;, &#34;giraffe&#34;, \
              &#34;backpack&#34;, &#34;umbrella&#34;, &#34;handbag&#34;, &#34;tie&#34;, &#34;suitcase&#34;, &#34;frisbee&#34;, &#34;skis&#34;, &#34;snowboard&#34;, \
              &#34;sports ball&#34;, &#34;kite&#34;, &#34;baseball bat&#34;, &#34;baseball glove&#34;, &#34;skateboard&#34;, &#34;surfboard&#34;, \
              &#34;tennis racket&#34;, &#34;bottle&#34;, &#34;wine glass&#34;, &#34;cup&#34;, &#34;fork&#34;, &#34;knife&#34;, &#34;spoon&#34;, &#34;bowl&#34;, &#34;banana&#34;, \
              &#34;apple&#34;, &#34;sandwich&#34;, &#34;orange&#34;, &#34;broccoli&#34;, &#34;carrot&#34;, &#34;hot dog&#34;, &#34;pizza&#34;, &#34;donut&#34;, &#34;cake&#34;, \
              &#34;chair&#34;, &#34;sofa&#34;, &#34;pottedplant&#34;, &#34;bed&#34;, &#34;diningtable&#34;, &#34;toilet&#34;, &#34;tvmonitor&#34;, &#34;laptop&#34;, &#34;mouse&#34;, \
              &#34;remote&#34;, &#34;keyboard&#34;, &#34;cell phone&#34;, &#34;microwave&#34;, &#34;oven&#34;, &#34;toaster&#34;, &#34;sink&#34;, &#34;refrigerator&#34;, \
              &#34;book&#34;, &#34;clock&#34;, &#34;vase&#34;, &#34;scissors&#34;, &#34;teddy bear&#34;, &#34;hair drier&#34;, &#34;toothbrush&#34;]

    # make the yolov3 model to predict 80 classes on COCO
    yolov3 = make_yolov3_model()

    # load the weights trained on COCO into the model
    weight_reader = WeightReader(weights_path)
    weight_reader.load_weights(yolov3)

    # preprocess the image
    image = cv2.imread(image_path)
    image_h, image_w, _ = image.shape
    new_image = preprocess_input(image, net_h, net_w)

    # run the prediction
    yolos = yolov3.predict(new_image)
    boxes = []

    for i in range(len(yolos)):
        # decode the output of the network
        boxes += decode_netout(yolos[i][0], anchors[i], obj_thresh, nms_thresh, net_h, net_w)

    # correct the sizes of the bounding boxes
    correct_yolo_boxes(boxes, image_h, image_w, net_h, net_w)

    # suppress non-maximal boxes
    do_nms(boxes, nms_thresh)     

    # draw bounding boxes on the image using labels
    draw_boxes(image, boxes, labels, obj_thresh) 
 
    # write the image with bounding boxes to file
    cv2.imwrite(image_path[:-4] + &#39;_detected&#39; + image_path[-4:], (image).astype(&#39;uint8&#39;)) 

if __name__ == &#39;__main__&#39;:
    args = argparser.parse_args()
    _main_(args)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="social-distancing-net.yolo3_one_file_to_detect_them_all.bbox_iou"><code class="name flex">
<span>def <span class="ident">bbox_iou</span></span>(<span>box1, box2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bbox_iou(box1, box2):
    intersect_w = _interval_overlap([box1.xmin, box1.xmax], [box2.xmin, box2.xmax])
    intersect_h = _interval_overlap([box1.ymin, box1.ymax], [box2.ymin, box2.ymax])
    
    intersect = intersect_w * intersect_h

    w1, h1 = box1.xmax-box1.xmin, box1.ymax-box1.ymin
    w2, h2 = box2.xmax-box2.xmin, box2.ymax-box2.ymin
    
    union = w1*h1 + w2*h2 - intersect
    
    return float(intersect) / union</code></pre>
</details>
</dd>
<dt id="social-distancing-net.yolo3_one_file_to_detect_them_all.correct_yolo_boxes"><code class="name flex">
<span>def <span class="ident">correct_yolo_boxes</span></span>(<span>boxes, image_h, image_w, net_h, net_w)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def correct_yolo_boxes(boxes, image_h, image_w, net_h, net_w):
    if (float(net_w)/image_w) &lt; (float(net_h)/image_h):
        new_w = net_w
        new_h = (image_h*net_w)/image_w
    else:
        new_h = net_w
        new_w = (image_w*net_h)/image_h
        
    for i in range(len(boxes)):
        x_offset, x_scale = (net_w - new_w)/2./net_w, float(new_w)/net_w
        y_offset, y_scale = (net_h - new_h)/2./net_h, float(new_h)/net_h
        
        boxes[i].xmin = int((boxes[i].xmin - x_offset) / x_scale * image_w)
        boxes[i].xmax = int((boxes[i].xmax - x_offset) / x_scale * image_w)
        boxes[i].ymin = int((boxes[i].ymin - y_offset) / y_scale * image_h)
        boxes[i].ymax = int((boxes[i].ymax - y_offset) / y_scale * image_h)</code></pre>
</details>
</dd>
<dt id="social-distancing-net.yolo3_one_file_to_detect_them_all.decode_netout"><code class="name flex">
<span>def <span class="ident">decode_netout</span></span>(<span>netout, anchors, obj_thresh, net_h, net_w)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_netout(netout, anchors, obj_thresh, net_h, net_w):
    grid_h, grid_w = netout.shape[:2]
    nb_box = 3
    netout = netout.reshape((grid_h, grid_w, nb_box, -1))
    nb_class = netout.shape[-1] - 5

    boxes = []

    netout[..., :2]  = _sigmoid(netout[..., :2])
    netout[..., 4:]  = _sigmoid(netout[..., 4:])
    netout[..., 5:]  = netout[..., 4][..., np.newaxis] * netout[..., 5:]
    netout[..., 5:] *= netout[..., 5:] &gt; obj_thresh

    for i in range(grid_h*grid_w):
        row = i / grid_w
        col = i % grid_w
        
        for b in range(nb_box):
            # 4th element is objectness score
            objectness = netout[int(row)][int(col)][b][4]
            #objectness = netout[..., :4]
            
            if(objectness.all() &lt;= obj_thresh): continue
            
            # first 4 elements are x, y, w, and h
            x, y, w, h = netout[int(row)][int(col)][b][:4]

            x = (col + x) / grid_w # center position, unit: image width
            y = (row + y) / grid_h # center position, unit: image height
            w = anchors[2 * b + 0] * np.exp(w) / net_w # unit: image width
            h = anchors[2 * b + 1] * np.exp(h) / net_h # unit: image height  
            
            # last elements are class probabilities
            classes = netout[int(row)][col][b][5:]
            
            box = BoundBox(x-w/2, y-h/2, x+w/2, y+h/2, objectness, classes)
            #box = BoundBox(x-w/2, y-h/2, x+w/2, y+h/2, None, classes)

            boxes.append(box)

    return boxes</code></pre>
</details>
</dd>
<dt id="social-distancing-net.yolo3_one_file_to_detect_them_all.do_nms"><code class="name flex">
<span>def <span class="ident">do_nms</span></span>(<span>boxes, nms_thresh)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_nms(boxes, nms_thresh):
    if len(boxes) &gt; 0:
        nb_class = len(boxes[0].classes)
    else:
        return
        
    for c in range(nb_class):
        sorted_indices = np.argsort([-box.classes[c] for box in boxes])

        for i in range(len(sorted_indices)):
            index_i = sorted_indices[i]

            if boxes[index_i].classes[c] == 0: continue

            for j in range(i+1, len(sorted_indices)):
                index_j = sorted_indices[j]

                if bbox_iou(boxes[index_i], boxes[index_j]) &gt;= nms_thresh:
                    boxes[index_j].classes[c] = 0</code></pre>
</details>
</dd>
<dt id="social-distancing-net.yolo3_one_file_to_detect_them_all.draw_boxes"><code class="name flex">
<span>def <span class="ident">draw_boxes</span></span>(<span>image, boxes, labels, obj_thresh)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_boxes(image, boxes, labels, obj_thresh):
    for box in boxes:
        label_str = &#39;&#39;
        label = -1
        
        for i in range(len(labels)):
            if box.classes[i] &gt; obj_thresh:
                label_str += labels[i]
                label = i
                print(labels[i] + &#39;: &#39; + str(box.classes[i]*100) + &#39;%&#39;)
                
        if label &gt;= 0:
            cv2.rectangle(image, (box.xmin,box.ymin), (box.xmax,box.ymax), (0,255,0), 3)
            cv2.putText(image, 
                        label_str + &#39; &#39; + str(box.get_score()), 
                        (box.xmin, box.ymin - 13), 
                        cv2.FONT_HERSHEY_SIMPLEX, 
                        1e-3 * image.shape[0], 
                        (0,255,0), 2)
        
    return image      </code></pre>
</details>
</dd>
<dt id="social-distancing-net.yolo3_one_file_to_detect_them_all.make_yolov3_model"><code class="name flex">
<span>def <span class="ident">make_yolov3_model</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_yolov3_model():
    input_image = Input(shape=(None, None, 3))

    # Layer  0 =&gt; 4
    x = _conv_block(input_image, [{&#39;filter&#39;: 32, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 0},
                                  {&#39;filter&#39;: 64, &#39;kernel&#39;: 3, &#39;stride&#39;: 2, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 1},
                                  {&#39;filter&#39;: 32, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 2},
                                  {&#39;filter&#39;: 64, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 3}])

    # Layer  5 =&gt; 8
    x = _conv_block(x, [{&#39;filter&#39;: 128, &#39;kernel&#39;: 3, &#39;stride&#39;: 2, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 5},
                        {&#39;filter&#39;:  64, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 6},
                        {&#39;filter&#39;: 128, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 7}])

    # Layer  9 =&gt; 11
    x = _conv_block(x, [{&#39;filter&#39;:  64, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 9},
                        {&#39;filter&#39;: 128, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 10}])

    # Layer 12 =&gt; 15
    x = _conv_block(x, [{&#39;filter&#39;: 256, &#39;kernel&#39;: 3, &#39;stride&#39;: 2, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 12},
                        {&#39;filter&#39;: 128, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 13},
                        {&#39;filter&#39;: 256, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 14}])

    # Layer 16 =&gt; 36
    for i in range(7):
        x = _conv_block(x, [{&#39;filter&#39;: 128, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 16+i*3},
                            {&#39;filter&#39;: 256, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 17+i*3}])
        
    skip_36 = x
        
    # Layer 37 =&gt; 40
    x = _conv_block(x, [{&#39;filter&#39;: 512, &#39;kernel&#39;: 3, &#39;stride&#39;: 2, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 37},
                        {&#39;filter&#39;: 256, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 38},
                        {&#39;filter&#39;: 512, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 39}])

    # Layer 41 =&gt; 61
    for i in range(7):
        x = _conv_block(x, [{&#39;filter&#39;: 256, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 41+i*3},
                            {&#39;filter&#39;: 512, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 42+i*3}])
        
    skip_61 = x
        
    # Layer 62 =&gt; 65
    x = _conv_block(x, [{&#39;filter&#39;: 1024, &#39;kernel&#39;: 3, &#39;stride&#39;: 2, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 62},
                        {&#39;filter&#39;:  512, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 63},
                        {&#39;filter&#39;: 1024, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 64}])

    # Layer 66 =&gt; 74
    for i in range(3):
        x = _conv_block(x, [{&#39;filter&#39;:  512, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 66+i*3},
                            {&#39;filter&#39;: 1024, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 67+i*3}])
        
    # Layer 75 =&gt; 79
    x = _conv_block(x, [{&#39;filter&#39;:  512, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 75},
                        {&#39;filter&#39;: 1024, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 76},
                        {&#39;filter&#39;:  512, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 77},
                        {&#39;filter&#39;: 1024, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 78},
                        {&#39;filter&#39;:  512, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 79}], skip=False)

    # Layer 80 =&gt; 82
    yolo_82 = _conv_block(x, [{&#39;filter&#39;: 1024, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True,  &#39;leaky&#39;: True,  &#39;layer_idx&#39;: 80},
                              {&#39;filter&#39;:  255, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: False, &#39;leaky&#39;: False, &#39;layer_idx&#39;: 81}], skip=False)

    # Layer 83 =&gt; 86
    x = _conv_block(x, [{&#39;filter&#39;: 256, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 84}], skip=False)
    x = UpSampling2D(2)(x)
    x = concatenate([x, skip_61])

    # Layer 87 =&gt; 91
    x = _conv_block(x, [{&#39;filter&#39;: 256, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 87},
                        {&#39;filter&#39;: 512, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 88},
                        {&#39;filter&#39;: 256, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 89},
                        {&#39;filter&#39;: 512, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 90},
                        {&#39;filter&#39;: 256, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True, &#39;layer_idx&#39;: 91}], skip=False)

    # Layer 92 =&gt; 94
    yolo_94 = _conv_block(x, [{&#39;filter&#39;: 512, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True,  &#39;leaky&#39;: True,  &#39;layer_idx&#39;: 92},
                              {&#39;filter&#39;: 255, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: False, &#39;leaky&#39;: False, &#39;layer_idx&#39;: 93}], skip=False)

    # Layer 95 =&gt; 98
    x = _conv_block(x, [{&#39;filter&#39;: 128, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True, &#39;leaky&#39;: True,   &#39;layer_idx&#39;: 96}], skip=False)
    x = UpSampling2D(2)(x)
    x = concatenate([x, skip_36])

    # Layer 99 =&gt; 106
    yolo_106 = _conv_block(x, [{&#39;filter&#39;: 128, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True,  &#39;leaky&#39;: True,  &#39;layer_idx&#39;: 99},
                               {&#39;filter&#39;: 256, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True,  &#39;leaky&#39;: True,  &#39;layer_idx&#39;: 100},
                               {&#39;filter&#39;: 128, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True,  &#39;leaky&#39;: True,  &#39;layer_idx&#39;: 101},
                               {&#39;filter&#39;: 256, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True,  &#39;leaky&#39;: True,  &#39;layer_idx&#39;: 102},
                               {&#39;filter&#39;: 128, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: True,  &#39;leaky&#39;: True,  &#39;layer_idx&#39;: 103},
                               {&#39;filter&#39;: 256, &#39;kernel&#39;: 3, &#39;stride&#39;: 1, &#39;bnorm&#39;: True,  &#39;leaky&#39;: True,  &#39;layer_idx&#39;: 104},
                               {&#39;filter&#39;: 255, &#39;kernel&#39;: 1, &#39;stride&#39;: 1, &#39;bnorm&#39;: False, &#39;leaky&#39;: False, &#39;layer_idx&#39;: 105}], skip=False)

    model = Model(input_image, [yolo_82, yolo_94, yolo_106])    
    return model</code></pre>
</details>
</dd>
<dt id="social-distancing-net.yolo3_one_file_to_detect_them_all.preprocess_input"><code class="name flex">
<span>def <span class="ident">preprocess_input</span></span>(<span>image, net_h, net_w)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preprocess_input(image, net_h, net_w):
    new_h, new_w, _ = image.shape

    # determine the new size of the image
    if (float(net_w)/new_w) &lt; (float(net_h)/new_h):
        new_h = (new_h * net_w)/new_w
        new_w = net_w
    else:
        new_w = (new_w * net_h)/new_h
        new_h = net_h

    # resize the image to the new size
    resized = cv2.resize(image[:,:,::-1]/255., (int(new_w), int(new_h)))

    # embed the image into the standard letter box
    new_image = np.ones((net_h, net_w, 3)) * 0.5
    new_image[int((net_h-new_h)//2):int((net_h+new_h)//2), int((net_w-new_w)//2):int((net_w+new_w)//2), :] = resized
    new_image = np.expand_dims(new_image, 0)

    return new_image</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="social-distancing-net.yolo3_one_file_to_detect_them_all.BoundBox"><code class="flex name class">
<span>class <span class="ident">BoundBox</span></span>
<span>(</span><span>xmin, ymin, xmax, ymax, objness=None, classes=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BoundBox:
    def __init__(self, xmin, ymin, xmax, ymax, objness = None, classes = None):
        self.xmin = xmin
        self.ymin = ymin
        self.xmax = xmax
        self.ymax = ymax
        
        self.objness = objness
        self.classes = classes

        self.label = -1
        self.score = -1

    def get_label(self):
        if self.label == -1:
            self.label = np.argmax(self.classes)
        
        return self.label
    
    def get_score(self):
        if self.score == -1:
            self.score = self.classes[self.get_label()]
            
        return self.score</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="social-distancing-net.yolo3_one_file_to_detect_them_all.BoundBox.get_label"><code class="name flex">
<span>def <span class="ident">get_label</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_label(self):
    if self.label == -1:
        self.label = np.argmax(self.classes)
    
    return self.label</code></pre>
</details>
</dd>
<dt id="social-distancing-net.yolo3_one_file_to_detect_them_all.BoundBox.get_score"><code class="name flex">
<span>def <span class="ident">get_score</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_score(self):
    if self.score == -1:
        self.score = self.classes[self.get_label()]
        
    return self.score</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="social-distancing-net.yolo3_one_file_to_detect_them_all.WeightReader"><code class="flex name class">
<span>class <span class="ident">WeightReader</span></span>
<span>(</span><span>weight_file)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WeightReader:
    def __init__(self, weight_file):
        with open(weight_file, &#39;rb&#39;) as w_f:
            major,    = struct.unpack(&#39;i&#39;, w_f.read(4))
            minor,    = struct.unpack(&#39;i&#39;, w_f.read(4))
            revision, = struct.unpack(&#39;i&#39;, w_f.read(4))

            if (major*10 + minor) &gt;= 2 and major &lt; 1000 and minor &lt; 1000:
                w_f.read(8)
            else:
                w_f.read(4)

            transpose = (major &gt; 1000) or (minor &gt; 1000)
            
            binary = w_f.read()

        self.offset = 0
        self.all_weights = np.frombuffer(binary, dtype=&#39;float32&#39;)
        
    def read_bytes(self, size):
        self.offset = self.offset + size
        return self.all_weights[self.offset-size:self.offset]

    def load_weights(self, model):
        for i in range(106):
            try:
                conv_layer = model.get_layer(&#39;conv_&#39; + str(i))
                print(&#34;loading weights of convolution #&#34; + str(i))

                if i not in [81, 93, 105]:
                    norm_layer = model.get_layer(&#39;bnorm_&#39; + str(i))

                    size = np.prod(norm_layer.get_weights()[0].shape)

                    beta  = self.read_bytes(size) # bias
                    gamma = self.read_bytes(size) # scale
                    mean  = self.read_bytes(size) # mean
                    var   = self.read_bytes(size) # variance            

                    weights = norm_layer.set_weights([gamma, beta, mean, var])  

                if len(conv_layer.get_weights()) &gt; 1:
                    bias   = self.read_bytes(np.prod(conv_layer.get_weights()[1].shape))
                    kernel = self.read_bytes(np.prod(conv_layer.get_weights()[0].shape))
                    
                    kernel = kernel.reshape(list(reversed(conv_layer.get_weights()[0].shape)))
                    kernel = kernel.transpose([2,3,1,0])
                    conv_layer.set_weights([kernel, bias])
                else:
                    kernel = self.read_bytes(np.prod(conv_layer.get_weights()[0].shape))
                    kernel = kernel.reshape(list(reversed(conv_layer.get_weights()[0].shape)))
                    kernel = kernel.transpose([2,3,1,0])
                    conv_layer.set_weights([kernel])
            except ValueError:
                print(&#34;no convolution #&#34; + str(i))     
    
    def reset(self):
        self.offset = 0</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="social-distancing-net.yolo3_one_file_to_detect_them_all.WeightReader.load_weights"><code class="name flex">
<span>def <span class="ident">load_weights</span></span>(<span>self, model)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_weights(self, model):
    for i in range(106):
        try:
            conv_layer = model.get_layer(&#39;conv_&#39; + str(i))
            print(&#34;loading weights of convolution #&#34; + str(i))

            if i not in [81, 93, 105]:
                norm_layer = model.get_layer(&#39;bnorm_&#39; + str(i))

                size = np.prod(norm_layer.get_weights()[0].shape)

                beta  = self.read_bytes(size) # bias
                gamma = self.read_bytes(size) # scale
                mean  = self.read_bytes(size) # mean
                var   = self.read_bytes(size) # variance            

                weights = norm_layer.set_weights([gamma, beta, mean, var])  

            if len(conv_layer.get_weights()) &gt; 1:
                bias   = self.read_bytes(np.prod(conv_layer.get_weights()[1].shape))
                kernel = self.read_bytes(np.prod(conv_layer.get_weights()[0].shape))
                
                kernel = kernel.reshape(list(reversed(conv_layer.get_weights()[0].shape)))
                kernel = kernel.transpose([2,3,1,0])
                conv_layer.set_weights([kernel, bias])
            else:
                kernel = self.read_bytes(np.prod(conv_layer.get_weights()[0].shape))
                kernel = kernel.reshape(list(reversed(conv_layer.get_weights()[0].shape)))
                kernel = kernel.transpose([2,3,1,0])
                conv_layer.set_weights([kernel])
        except ValueError:
            print(&#34;no convolution #&#34; + str(i))     </code></pre>
</details>
</dd>
<dt id="social-distancing-net.yolo3_one_file_to_detect_them_all.WeightReader.read_bytes"><code class="name flex">
<span>def <span class="ident">read_bytes</span></span>(<span>self, size)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_bytes(self, size):
    self.offset = self.offset + size
    return self.all_weights[self.offset-size:self.offset]</code></pre>
</details>
</dd>
<dt id="social-distancing-net.yolo3_one_file_to_detect_them_all.WeightReader.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    self.offset = 0</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="social-distancing-net" href="index.html">social-distancing-net</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="social-distancing-net.yolo3_one_file_to_detect_them_all.bbox_iou" href="#social-distancing-net.yolo3_one_file_to_detect_them_all.bbox_iou">bbox_iou</a></code></li>
<li><code><a title="social-distancing-net.yolo3_one_file_to_detect_them_all.correct_yolo_boxes" href="#social-distancing-net.yolo3_one_file_to_detect_them_all.correct_yolo_boxes">correct_yolo_boxes</a></code></li>
<li><code><a title="social-distancing-net.yolo3_one_file_to_detect_them_all.decode_netout" href="#social-distancing-net.yolo3_one_file_to_detect_them_all.decode_netout">decode_netout</a></code></li>
<li><code><a title="social-distancing-net.yolo3_one_file_to_detect_them_all.do_nms" href="#social-distancing-net.yolo3_one_file_to_detect_them_all.do_nms">do_nms</a></code></li>
<li><code><a title="social-distancing-net.yolo3_one_file_to_detect_them_all.draw_boxes" href="#social-distancing-net.yolo3_one_file_to_detect_them_all.draw_boxes">draw_boxes</a></code></li>
<li><code><a title="social-distancing-net.yolo3_one_file_to_detect_them_all.make_yolov3_model" href="#social-distancing-net.yolo3_one_file_to_detect_them_all.make_yolov3_model">make_yolov3_model</a></code></li>
<li><code><a title="social-distancing-net.yolo3_one_file_to_detect_them_all.preprocess_input" href="#social-distancing-net.yolo3_one_file_to_detect_them_all.preprocess_input">preprocess_input</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="social-distancing-net.yolo3_one_file_to_detect_them_all.BoundBox" href="#social-distancing-net.yolo3_one_file_to_detect_them_all.BoundBox">BoundBox</a></code></h4>
<ul class="">
<li><code><a title="social-distancing-net.yolo3_one_file_to_detect_them_all.BoundBox.get_label" href="#social-distancing-net.yolo3_one_file_to_detect_them_all.BoundBox.get_label">get_label</a></code></li>
<li><code><a title="social-distancing-net.yolo3_one_file_to_detect_them_all.BoundBox.get_score" href="#social-distancing-net.yolo3_one_file_to_detect_them_all.BoundBox.get_score">get_score</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="social-distancing-net.yolo3_one_file_to_detect_them_all.WeightReader" href="#social-distancing-net.yolo3_one_file_to_detect_them_all.WeightReader">WeightReader</a></code></h4>
<ul class="">
<li><code><a title="social-distancing-net.yolo3_one_file_to_detect_them_all.WeightReader.load_weights" href="#social-distancing-net.yolo3_one_file_to_detect_them_all.WeightReader.load_weights">load_weights</a></code></li>
<li><code><a title="social-distancing-net.yolo3_one_file_to_detect_them_all.WeightReader.read_bytes" href="#social-distancing-net.yolo3_one_file_to_detect_them_all.WeightReader.read_bytes">read_bytes</a></code></li>
<li><code><a title="social-distancing-net.yolo3_one_file_to_detect_them_all.WeightReader.reset" href="#social-distancing-net.yolo3_one_file_to_detect_them_all.WeightReader.reset">reset</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>